##  SamplerBox##  author:    Joseph Ernest (twitter: @JosephErnest, mail: contact@samplerbox.org)#  url:       http://www.samplerbox.org/#  license:   Creative Commons ShareAlike 3.0 (http://creativecommons.org/licenses/by-sa/3.0/)##  samplerbox.py: Main file#  This is a fork to port python3 for the Macintosh #  by Michael Mak, Hong Kong#  The sound output on the Mac is known to be good.#  buttons and LCD codes were deleted#	class and def moved to the front, init gathered together, so a clear work flow shown later########################################## LOCAL# CONFIG#########################################AUDIO_DEVICE_ID = 1                     # Mac internal is 1SAMPLES_DIR = "."                       # The root directory containing the sample-sets. Example: "/samples/" to look for on USBMAX_POLYPHONY = 80                      # This can be set higher, but 80 is a safe value#these not useful on Mac#USE_SERIALPORT_MIDI = False             # Set to True to enable MIDI IN via SerialPort#USE_I2C_7SEGMENTDISPLAY = False         # Set to True to use a 7-segment display via I2C#USE_BUTTONS = False                     # Set to True to use momentary buttons (connected to RaspberryPi's GPIO pins) to change preset########################################## IMPORT# MODULES#########################################import waveimport timeimport numpy, sysimport osimport reimport sounddevice # may consider/compare pyaudio#import pyaudio  #pip3 failed to install this on my Macimport threadingfrom chunk import Chunkimport struct#import rtmidi_python as rtmidi  # rtmidi_python != rtmidi ???from rtmidi.midiutil import open_midiinputimport samplerbox_audio########################################## SLIGHT MODIFICATION OF PYTHON'S WAVE MODULE# TO READ CUE MARKERS & LOOP MARKERS##  sound objects creation....#########################################class waveread(wave.Wave_read):	#to do: try to port GarageBand files and use	    def initfp(self, file):        self._convert = None        self._soundpos = 0        self._cue = []        self._loops = []        self._ieee = False        self._file = Chunk(file, bigendian=0)        if self._file.getname() != b'RIFF':            print('file does not start with RIFF id')        if self._file.read(4) != b'WAVE':            print('not a WAVE file')        self._fmt_chunk_read = 0        self._data_chunk = None        while 1:            self._data_seek_needed = 1            try:                chunk = Chunk(self._file, bigendian=0)            except EOFError:                break            chunkname = chunk.getname()            if chunkname == b'fmt ':                self._read_fmt_chunk(chunk)                self._fmt_chunk_read = 1            elif chunkname == b'data':                if not self._fmt_chunk_read:                    print('data chunk before fmt chunk')                self._data_chunk = chunk                self._nframes = chunk.chunksize // self._framesize                self._data_seek_needed = 0            elif chunkname == b'cue ':                numcue = struct.unpack('<i', chunk.read(4))[0]                for i in range(numcue):                    id, position, datachunkid, chunkstart, blockstart, sampleoffset = struct.unpack('<iiiiii', chunk.read(24))                    self._cue.append(sampleoffset)            elif chunkname == b'smpl':                manuf, prod, sampleperiod, midiunitynote, midipitchfraction, smptefmt, smpteoffs, numsampleloops, samplerdata = struct.unpack(                    '<iiiiiiiii', chunk.read(36))                for i in range(numsampleloops):                    cuepointid, type, start, end, fraction, playcount = struct.unpack('<iiiiii', chunk.read(24))                    self._loops.append([start, end])            chunk.skip()        if not self._fmt_chunk_read or not self._data_chunk:            print('fmt chunk and/or data chunk missing')    def getmarkers(self):        return self._cue    def getloops(self):        return self._loops########################################## MIXER CLASSES##########################################class PlayingSound:    def __init__(self, sound, note):        self.sound = sound        self.pos = 0        self.fadeoutpos = 0        self.isfadeout = False        self.note = note    def fadeout(self, i):        self.isfadeout = True    def stop(self):        try:            playingsounds.remove(self)        except:            passclass Sound:	#sound are loaded as numpy array	    def __init__(self, filename, midinote, velocity):        wf = waveread(filename)        self.fname = filename        self.midinote = midinote        self.velocity = velocity        if wf.getloops():            self.loop = wf.getloops()[0][0]            self.nframes = wf.getloops()[0][1] + 2        else:            self.loop = -1            self.nframes = wf.getnframes()        self.data = self.frames2array(wf.readframes(self.nframes), wf.getsampwidth(), wf.getnchannels())        wf.close()    def play(self, note):        snd = PlayingSound(self, note)        playingsounds.append(snd)        return snd    def frames2array(self, data, sampwidth, numchan):        if sampwidth == 2:        	#was fromstring, deprecated in python3            npdata = numpy.frombuffer(data, dtype=numpy.int16)        elif sampwidth == 3:            npdata = samplerbox_audio.binary24_to_int16(data, len(data)/3)        if numchan == 1:            npdata = numpy.repeat(npdata, 2)        return npdata########################################## AUDIO AND MIDI CALLBACKS#########################################def AudioCallback(outdata, frame_count, time_info, status):    global playingsounds    rmlist = []    playingsounds = playingsounds[-MAX_POLYPHONY:]    b = samplerbox_audio.mixaudiobuffers(playingsounds, rmlist, frame_count, FADEOUT, FADEOUTLENGTH, SPEED)    for e in rmlist:        try:            playingsounds.remove(e)        except:            pass    b *= globalvolume    odata = (b.astype(numpy.int16)).tostring()    return (odata, pyaudio.paContinue)	####outdata[:] = b.reshape(outdata.shape)def MidiCallback(message_with_ts, dummy):    global playingnotes, sustain, sustainplayingnotes, globaltranspose    global preset    message=message_with_ts[0]    print(message)    #print(dummy) , well rtmidi passed 2 items to the callback. has to put a dummy here or else py complained    messagetype = message[0]# >> 4    messagechannel = 1   #(message[0] & 15) + 1    note = message[1] if len(message) > 1 else None    midinote = note    velocity = message[2] if len(message) > 2 else None    if messagetype == 9 and velocity == 0:        messagetype = 8    if messagetype == 144:    # Note on        midinote += globaltranspose                try:            playingnotes.setdefault(midinote, []).append(samples[midinote, velocity].play(midinote))            print(playingnotes);        except:            pass	    elif messagetype ==128:  # Note off        midinote += globaltranspose        if midinote in playingnotes:            for n in playingnotes[midinote]:                if sustain:                    sustainplayingnotes.append(n)                else:                    n.fadeout(50)            playingnotes[midinote] = []		#to do: check if 12 is the number    elif messagetype == 12:  # Program change        print('Program change ' + str(note))        preset = note        LoadSamples()		#to do: check the numbers    elif (messagetype == 11) and (note == 64) and (velocity < 64):  # sustain pedal off        for n in sustainplayingnotes:            n.fadeout(50)        sustainplayingnotes = []        sustain = False    elif (messagetype == 11) and (note == 64) and (velocity >= 64):  # sustain pedal on        sustain = True########################################## LOAD SAMPLES########################################### ? be enabled for OSX?def LoadSamples():    global LoadingThread    global LoadingInterrupt    if LoadingThread:        LoadingInterrupt = True        LoadingThread.join()        LoadingThread = None    LoadingInterrupt = False    LoadingThread = threading.Thread(target=ActuallyLoad)    LoadingThread.daemon = True    LoadingThread.start()def ActuallyLoad():    global preset    global samples    global playingsounds    global globalvolume, globaltranspose    playingsounds = []    samples = {}    globalvolume = 10 ** (-12.0/20)  # -12dB default global volume    globaltranspose = 0    samplesdir = SAMPLES_DIR if os.listdir(SAMPLES_DIR) else '.'      # use current folder (containing 0 Saw) if no user media containing samples has been found    basename = next((f for f in os.listdir(samplesdir) if f.startswith("%d " % preset)), None)      # or next(glob.iglob("blah*"), None)    if basename:        dirname = os.path.join(samplesdir, basename)    if not basename:        print('Preset empty: %s' % preset)                return    print('Preset loading: %s (%s)' % (preset, basename))    '''    dirname = "/home/pi/SamplerBox_sounds/1 GrandPiano/"    print 'Preset loading: %s (%s)' % (preset, dirname)        '''    	#m-- test out this definition.txt, its about using diff samples at diff velecity    definitionfname = os.path.join(dirname, "definition.txt")    if os.path.isfile(definitionfname):        print ("definition found")        with open(definitionfname, 'r') as definitionfile:            for i, pattern in enumerate(definitionfile):                try:                    if r'%%volume' in pattern:        # %%paramaters are global parameters                        globalvolume *= 10 ** (float(pattern.split('=')[1].strip()) / 20)                        continue                    if r'%%transpose' in pattern:                        globaltranspose = int(pattern.split('=')[1].strip())                        continue                    defaultparams = {'midinote': '0', 'velocity': '127', 'notename': ''}                    if len(pattern.split(',')) > 1:                        defaultparams.update(dict([item.split('=') for item in pattern.split(',', 1)[1].replace(' ', '').replace('%', '').split(',')]))                    pattern = pattern.split(',')[0]                    pattern = re.escape(pattern.strip())                    pattern = pattern.replace(r"\%midinote", r"(?P<midinote>\d+)").replace(r"\%velocity", r"(?P<velocity>\d+)")\                                     .replace(r"\%notename", r"(?P<notename>[A-Ga-g]#?[0-9])").replace(r"\*", r".*?").strip()    # .*? => non greedy                    for fname in os.listdir(dirname):                        if LoadingInterrupt:                            return                        m = re.match(pattern, fname)                        if m:                            info = m.groupdict()                            midinote = int(info.get('midinote', defaultparams['midinote']))                            velocity = int(info.get('velocity', defaultparams['velocity']))                            notename = info.get('notename', defaultparams['notename'])                            if notename:                                midinote = NOTES.index(notename[:-1].lower()) + (int(notename[-1])+2) * 12                            samples[midinote, velocity] = Sound(os.path.join(dirname, fname), midinote, velocity)                except:                    print("Error in definition file, skipping line %s." % (i+1))    else:        for midinote in range(0, 127):            if LoadingInterrupt:                return            file = os.path.join(dirname, "%d.wav" % midinote)            if os.path.isfile(file):                samples[midinote, 127] = Sound(file, midinote, 127)    initial_keys = set(samples.keys())    for midinote in range(128):        lastvelocity = None        for velocity in range(128):            if (midinote, velocity) not in initial_keys:                samples[midinote, velocity] = lastvelocity            else:                if not lastvelocity:                    for v in range(velocity):                        samples[midinote, v] = samples[midinote, velocity]                lastvelocity = samples[midinote, velocity]        if not lastvelocity:            for velocity in range(128):                try:                    samples[midinote, velocity] = samples[midinote-1, velocity]                except:                    pass    if len(initial_keys) > 0:        print('Preset loaded: ' + str(preset))            else:        print('Preset empty: ' + str(preset))        ########################################## OPEN AUDIO DEVICE###########################################this using pyaudio?def testNote(mnote, vel):    global playingnotes, sustain, sustainplayingnotes    global preset    try:        playingnotes.setdefault(mnote, []).append(samples[mnote, vel].play(mnote))    except:        pass#a long FADEOUTLENGTH? TO DO: test other valuesFADEOUTLENGTH = 30000FADEOUT = numpy.linspace(1., 0., FADEOUTLENGTH)            # by default, float64FADEOUT = numpy.power(FADEOUT, 6)FADEOUT = numpy.append(FADEOUT, numpy.zeros(FADEOUTLENGTH, numpy.float32)).astype(numpy.float32)SPEED = numpy.power(2, numpy.arange(0.0, 84.0)/12).astype(numpy.float32)LoadingThread = NoneLoadingInterrupt = Falsesamples = {}playingnotes = {}sustainplayingnotes = []sustain = Falseplayingsounds = []globalvolume = 10 ** (-12.0/20)  # -12dB default global volumeglobaltranspose = 0#available sample wav files 36,48,60,72NOTES = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"]sounddevice.query_devices()sounddevice.default.device=AUDIO_DEVICE_IDprint("sound device OK")'''try:    sd = sounddevice.OutputStream(device=AUDIO_DEVICE_ID, blocksize=512, samplerate=44100, channels=2, dtype='int16', callback=AudioCallback)    sd.start()    print('Opened audio device #%i' % AUDIO_DEVICE_ID)except:    print('Invalid audio device #%i' % AUDIO_DEVICE_ID)    exit(1)''' ########################################## MIDI IN via SERIAL PORT deleted !!########################################## LOAD FIRST SOUNDBANK#########################################preset = 0LoadSamples() ########################################## MIDI DEVICES DETECTION# MAIN LOOP#https://spotlightkid.github.io/python-rtmidi/rtmidi.html#usage-example#########################################port =Nonetry:    midiin, port_name = open_midiinput(0)    print("Midi in ok.")except (EOFError, KeyboardInterrupt):	print("Midi in failed.")	sys.exit()print("Entering main loop. Press Control-C to exit.")timer = time.time()while True:	midiin.set_callback( MidiCallback )		#proof of working, play a note every 2 seconds	testNote(120,100)	time.sleep(2)	'''	msg = midiin.get_message()	if msg:		message, deltatime = msg		timer += deltatime		#print("[%s] @%0.6f %r" % (port_name, timer, message))		print( "%r" % ( message))	time.sleep(0.01)	''''''midiin.set_callback( MidiCallback )testNote(120,100)time.sleep(2)midi_in = [rtmidi.MidiIn()]previous = []while True:    for port in midi_in[0].ports:        if port not in previous and b'Midi Through' not in port:            midi_in.append(rtmidi.MidiIn(b'in'))            midi_in[-1].callback = MidiCallback            midi_in[-1].open_port(port)            print('Opened MIDI: ' + str(port))    previous = midi_in[0].ports    time.sleep(2)'''    